// Code generated by protoc-gen-gogo.
// source: zvelo/msg/status.proto
// DO NOT EDIT!

package msg

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import strconv "strconv"

import strings "strings"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Status_Code int32

const (
	UNKNOWN_STATUS_CODE Status_Code = 0
	// 100s
	STATUS_CONTINUE            Status_Code = 100
	STATUS_SWITCHING_PROTOCOLS Status_Code = 101
	// 200s
	STATUS_OK                     Status_Code = 200
	STATUS_CREATED                Status_Code = 201
	STATUS_ACCEPTED               Status_Code = 202
	STATUS_NON_AUTHORITATIVE_INFO Status_Code = 203
	STATUS_NO_CONTENT             Status_Code = 204
	STATUS_RESET_CONTENT          Status_Code = 205
	STATUS_PARTIAL_CONTENT        Status_Code = 206
	// 300s
	STATUS_MULTIPLE_CHOICES   Status_Code = 300
	STATUS_MOVED_PERMANENTLY  Status_Code = 301
	STATUS_FOUND              Status_Code = 302
	STATUS_SEE_OTHER          Status_Code = 303
	STATUS_NOT_MODIFIED       Status_Code = 304
	STATUS_USE_PROXY          Status_Code = 305
	STATUS_TEMPORARY_REDIRECT Status_Code = 307
	// 400s
	STATUS_BAD_REQUEST                     Status_Code = 400
	STATUS_UNAUTHORIZED                    Status_Code = 401
	STATUS_PAYMENT_REQUIRED                Status_Code = 402
	STATUS_FORBIDDEN                       Status_Code = 403
	STATUS_NOT_FOUND                       Status_Code = 404
	STATUS_METHOD_NOT_ALLOWED              Status_Code = 405
	STATUS_NOT_ACCEPTABLE                  Status_Code = 406
	STATUS_PROXY_AUTH_REQUIRED             Status_Code = 407
	STATUS_REQUEST_TIMEOUT                 Status_Code = 408
	STATUS_CONFLICT                        Status_Code = 409
	STATUS_GONE                            Status_Code = 410
	STATUS_LENGTH_REQUIRED                 Status_Code = 411
	STATUS_PRECONDITION_FAILED             Status_Code = 412
	STATUS_REQUEST_ENTITY_TOO_LARGE        Status_Code = 413
	STATUS_REQUEST_URI_TOO_LONG            Status_Code = 414
	STATUS_UNSUPPORTED_MEDIA_TYPE          Status_Code = 415
	STATUS_REQUESTED_RANGE_NOT_SATISFIABLE Status_Code = 416
	STATUS_EXPECTATION_FAILED              Status_Code = 417
	STATUS_TEAPOT                          Status_Code = 418
	STATUS_PRECONDITION_REQUIRED           Status_Code = 428
	STATUS_TOO_MANY_REQUESTS               Status_Code = 429
	STATUS_REQUEST_HEADER_FIELDS_TOO_LARGE Status_Code = 431
	STATUS_UNAVAILABLE_FOR_LEGAL_REASONS   Status_Code = 451
	// 500s
	STATUS_INTERNAL_SERVER_ERROR           Status_Code = 500
	STATUS_NOT_IMPLEMENTED                 Status_Code = 501
	STATUS_BAD_GATEWAY                     Status_Code = 502
	STATUS_SERVICE_UNAVAILABLE             Status_Code = 503
	STATUS_GATEWAY_TIMEOUT                 Status_Code = 504
	STATUS_HTTP_VERSION_NOT_SUPPORTED      Status_Code = 505
	STATUS_NETWORK_AUTHENTICATION_REQUIRED Status_Code = 511
)

var Status_Code_name = map[int32]string{
	0:   "UNKNOWN_STATUS_CODE",
	100: "STATUS_CONTINUE",
	101: "STATUS_SWITCHING_PROTOCOLS",
	200: "STATUS_OK",
	201: "STATUS_CREATED",
	202: "STATUS_ACCEPTED",
	203: "STATUS_NON_AUTHORITATIVE_INFO",
	204: "STATUS_NO_CONTENT",
	205: "STATUS_RESET_CONTENT",
	206: "STATUS_PARTIAL_CONTENT",
	300: "STATUS_MULTIPLE_CHOICES",
	301: "STATUS_MOVED_PERMANENTLY",
	302: "STATUS_FOUND",
	303: "STATUS_SEE_OTHER",
	304: "STATUS_NOT_MODIFIED",
	305: "STATUS_USE_PROXY",
	307: "STATUS_TEMPORARY_REDIRECT",
	400: "STATUS_BAD_REQUEST",
	401: "STATUS_UNAUTHORIZED",
	402: "STATUS_PAYMENT_REQUIRED",
	403: "STATUS_FORBIDDEN",
	404: "STATUS_NOT_FOUND",
	405: "STATUS_METHOD_NOT_ALLOWED",
	406: "STATUS_NOT_ACCEPTABLE",
	407: "STATUS_PROXY_AUTH_REQUIRED",
	408: "STATUS_REQUEST_TIMEOUT",
	409: "STATUS_CONFLICT",
	410: "STATUS_GONE",
	411: "STATUS_LENGTH_REQUIRED",
	412: "STATUS_PRECONDITION_FAILED",
	413: "STATUS_REQUEST_ENTITY_TOO_LARGE",
	414: "STATUS_REQUEST_URI_TOO_LONG",
	415: "STATUS_UNSUPPORTED_MEDIA_TYPE",
	416: "STATUS_REQUESTED_RANGE_NOT_SATISFIABLE",
	417: "STATUS_EXPECTATION_FAILED",
	418: "STATUS_TEAPOT",
	428: "STATUS_PRECONDITION_REQUIRED",
	429: "STATUS_TOO_MANY_REQUESTS",
	431: "STATUS_REQUEST_HEADER_FIELDS_TOO_LARGE",
	451: "STATUS_UNAVAILABLE_FOR_LEGAL_REASONS",
	500: "STATUS_INTERNAL_SERVER_ERROR",
	501: "STATUS_NOT_IMPLEMENTED",
	502: "STATUS_BAD_GATEWAY",
	503: "STATUS_SERVICE_UNAVAILABLE",
	504: "STATUS_GATEWAY_TIMEOUT",
	505: "STATUS_HTTP_VERSION_NOT_SUPPORTED",
	511: "STATUS_NETWORK_AUTHENTICATION_REQUIRED",
}
var Status_Code_value = map[string]int32{
	"UNKNOWN_STATUS_CODE":                    0,
	"STATUS_CONTINUE":                        100,
	"STATUS_SWITCHING_PROTOCOLS":             101,
	"STATUS_OK":                              200,
	"STATUS_CREATED":                         201,
	"STATUS_ACCEPTED":                        202,
	"STATUS_NON_AUTHORITATIVE_INFO":          203,
	"STATUS_NO_CONTENT":                      204,
	"STATUS_RESET_CONTENT":                   205,
	"STATUS_PARTIAL_CONTENT":                 206,
	"STATUS_MULTIPLE_CHOICES":                300,
	"STATUS_MOVED_PERMANENTLY":               301,
	"STATUS_FOUND":                           302,
	"STATUS_SEE_OTHER":                       303,
	"STATUS_NOT_MODIFIED":                    304,
	"STATUS_USE_PROXY":                       305,
	"STATUS_TEMPORARY_REDIRECT":              307,
	"STATUS_BAD_REQUEST":                     400,
	"STATUS_UNAUTHORIZED":                    401,
	"STATUS_PAYMENT_REQUIRED":                402,
	"STATUS_FORBIDDEN":                       403,
	"STATUS_NOT_FOUND":                       404,
	"STATUS_METHOD_NOT_ALLOWED":              405,
	"STATUS_NOT_ACCEPTABLE":                  406,
	"STATUS_PROXY_AUTH_REQUIRED":             407,
	"STATUS_REQUEST_TIMEOUT":                 408,
	"STATUS_CONFLICT":                        409,
	"STATUS_GONE":                            410,
	"STATUS_LENGTH_REQUIRED":                 411,
	"STATUS_PRECONDITION_FAILED":             412,
	"STATUS_REQUEST_ENTITY_TOO_LARGE":        413,
	"STATUS_REQUEST_URI_TOO_LONG":            414,
	"STATUS_UNSUPPORTED_MEDIA_TYPE":          415,
	"STATUS_REQUESTED_RANGE_NOT_SATISFIABLE": 416,
	"STATUS_EXPECTATION_FAILED":              417,
	"STATUS_TEAPOT":                          418,
	"STATUS_PRECONDITION_REQUIRED":           428,
	"STATUS_TOO_MANY_REQUESTS":               429,
	"STATUS_REQUEST_HEADER_FIELDS_TOO_LARGE": 431,
	"STATUS_UNAVAILABLE_FOR_LEGAL_REASONS":   451,
	"STATUS_INTERNAL_SERVER_ERROR":           500,
	"STATUS_NOT_IMPLEMENTED":                 501,
	"STATUS_BAD_GATEWAY":                     502,
	"STATUS_SERVICE_UNAVAILABLE":             503,
	"STATUS_GATEWAY_TIMEOUT":                 504,
	"STATUS_HTTP_VERSION_NOT_SUPPORTED":      505,
	"STATUS_NETWORK_AUTHENTICATION_REQUIRED": 511,
}

func (Status_Code) EnumDescriptor() ([]byte, []int) { return fileDescriptorStatus, []int{0, 0} }

type Status struct {
	Code        Status_Code `protobuf:"varint,1,opt,name=code,proto3,enum=zvelo.msg.Status_Code" json:"code,omitempty"`
	Message     string      `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	FetchStatus *Status     `protobuf:"bytes,3,opt,name=fetch_status,json=fetchStatus" json:"fetch_status,omitempty"`
	Location    string      `protobuf:"bytes,4,opt,name=location,proto3" json:"location,omitempty"`
}

func (m *Status) Reset()                    { *m = Status{} }
func (*Status) ProtoMessage()               {}
func (*Status) Descriptor() ([]byte, []int) { return fileDescriptorStatus, []int{0} }

func (m *Status) GetCode() Status_Code {
	if m != nil {
		return m.Code
	}
	return UNKNOWN_STATUS_CODE
}

func (m *Status) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *Status) GetFetchStatus() *Status {
	if m != nil {
		return m.FetchStatus
	}
	return nil
}

func (m *Status) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func init() {
	proto.RegisterType((*Status)(nil), "zvelo.msg.Status")
	proto.RegisterEnum("zvelo.msg.Status_Code", Status_Code_name, Status_Code_value)
}
func (this *Status) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*Status)
	if !ok {
		that2, ok := that.(Status)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if this.Code != that1.Code {
		if this.Code < that1.Code {
			return -1
		}
		return 1
	}
	if this.Message != that1.Message {
		if this.Message < that1.Message {
			return -1
		}
		return 1
	}
	if c := this.FetchStatus.Compare(that1.FetchStatus); c != 0 {
		return c
	}
	if this.Location != that1.Location {
		if this.Location < that1.Location {
			return -1
		}
		return 1
	}
	return 0
}
func (x Status_Code) String() string {
	s, ok := Status_Code_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Status) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Status)
	if !ok {
		that2, ok := that.(Status)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Status")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Status but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Status but is not nil && this == nil")
	}
	if this.Code != that1.Code {
		return fmt.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if this.Message != that1.Message {
		return fmt.Errorf("Message this(%v) Not Equal that(%v)", this.Message, that1.Message)
	}
	if !this.FetchStatus.Equal(that1.FetchStatus) {
		return fmt.Errorf("FetchStatus this(%v) Not Equal that(%v)", this.FetchStatus, that1.FetchStatus)
	}
	if this.Location != that1.Location {
		return fmt.Errorf("Location this(%v) Not Equal that(%v)", this.Location, that1.Location)
	}
	return nil
}
func (this *Status) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Status)
	if !ok {
		that2, ok := that.(Status)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	if !this.FetchStatus.Equal(that1.FetchStatus) {
		return false
	}
	if this.Location != that1.Location {
		return false
	}
	return true
}
func (this *Status) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&msg.Status{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	if this.FetchStatus != nil {
		s = append(s, "FetchStatus: "+fmt.Sprintf("%#v", this.FetchStatus)+",\n")
	}
	s = append(s, "Location: "+fmt.Sprintf("%#v", this.Location)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringStatus(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Status) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.Code))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.FetchStatus != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.FetchStatus.Size()))
		n1, err := m.FetchStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Location) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Location)))
		i += copy(dAtA[i:], m.Location)
	}
	return i, nil
}

func encodeFixed64Status(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Status(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintStatus(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Status) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovStatus(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.FetchStatus != nil {
		l = m.FetchStatus.Size()
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func sovStatus(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozStatus(x uint64) (n int) {
	return sovStatus(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Status) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Status{`,
		`Code:` + fmt.Sprintf("%v", this.Code) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`FetchStatus:` + strings.Replace(fmt.Sprintf("%v", this.FetchStatus), "Status", "Status", 1) + `,`,
		`Location:` + fmt.Sprintf("%v", this.Location) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringStatus(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Status) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (Status_Code(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FetchStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FetchStatus == nil {
				m.FetchStatus = &Status{}
			}
			if err := m.FetchStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStatus(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthStatus
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipStatus(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthStatus = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStatus   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("zvelo/msg/status.proto", fileDescriptorStatus) }

var fileDescriptorStatus = []byte{
	// 950 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x6c, 0x55, 0xcb, 0x6e, 0x1c, 0x45,
	0x14, 0x75, 0x4d, 0x59, 0x01, 0x97, 0x8d, 0x29, 0x97, 0x13, 0x7b, 0xe2, 0x24, 0x1d, 0xc7, 0x8a,
	0x22, 0x03, 0x92, 0x23, 0x05, 0x7e, 0xa0, 0xdc, 0x75, 0x67, 0xa6, 0xe4, 0xee, 0xaa, 0xa6, 0xba,
	0xda, 0xce, 0x64, 0x53, 0x32, 0xf6, 0x60, 0x22, 0xc5, 0x0c, 0x62, 0x06, 0x16, 0xac, 0xf8, 0x04,
	0xf3, 0x7e, 0x3f, 0x57, 0x59, 0x24, 0x04, 0xc4, 0x27, 0xb0, 0x09, 0x4f, 0x65, 0xc9, 0x32, 0x9e,
	0x6c, 0xd8, 0x20, 0x65, 0xc1, 0x73, 0x05, 0xea, 0x9e, 0x9e, 0x76, 0xd9, 0xc9, 0xb2, 0xcf, 0xb9,
	0x75, 0xeb, 0xdc, 0x73, 0x4f, 0x77, 0x93, 0xb9, 0xd7, 0x5e, 0xed, 0x5c, 0xeb, 0x5e, 0xdc, 0xed,
	0xed, 0x5c, 0xec, 0xf5, 0x37, 0xfb, 0xaf, 0xf4, 0x56, 0x5e, 0x7a, 0xb9, 0xdb, 0xef, 0xb2, 0x89,
	0x02, 0x5f, 0xd9, 0xed, 0xed, 0x2c, 0xed, 0x4d, 0x91, 0x63, 0x69, 0xc1, 0xb1, 0x27, 0xc9, 0xf8,
	0x56, 0x77, 0xbb, 0x53, 0x47, 0x8b, 0x68, 0x79, 0xfa, 0xd2, 0xdc, 0x4a, 0x55, 0xb4, 0x32, 0x2c,
	0x58, 0x09, 0xbb, 0xdb, 0x1d, 0x53, 0xd4, 0xb0, 0x3a, 0x79, 0x64, 0xb7, 0xd3, 0xeb, 0x6d, 0xee,
	0x74, 0xea, 0xb5, 0x45, 0xb4, 0x3c, 0x61, 0x46, 0x8f, 0xec, 0x19, 0x32, 0xf5, 0x7c, 0xa7, 0xbf,
	0xf5, 0x82, 0x1b, 0xde, 0x58, 0xc7, 0x8b, 0x68, 0x79, 0xf2, 0xd2, 0xcc, 0x03, 0xdd, 0xcc, 0x64,
	0x51, 0x56, 0xde, 0xbd, 0x40, 0x1e, 0xbd, 0xd6, 0xdd, 0xda, 0xec, 0x5f, 0xed, 0xbe, 0x58, 0x1f,
	0x2f, 0x1a, 0x56, 0xcf, 0x4b, 0xbf, 0x13, 0x32, 0x9e, 0x5f, 0xcd, 0xe6, 0xc9, 0x6c, 0xa6, 0xd6,
	0x94, 0xde, 0x50, 0x2e, 0xb5, 0xdc, 0x66, 0xa9, 0x0b, 0xb5, 0x00, 0x3a, 0xc6, 0x66, 0xc9, 0xe3,
	0x15, 0xa0, 0xac, 0x54, 0x19, 0xd0, 0x6d, 0x16, 0x90, 0x85, 0x12, 0x4c, 0x37, 0xa4, 0x0d, 0x5b,
	0x52, 0x35, 0x5d, 0x62, 0xb4, 0xd5, 0xa1, 0x8e, 0x52, 0xda, 0x61, 0xd3, 0x64, 0xa2, 0xe4, 0xf5,
	0x1a, 0xbd, 0x8d, 0xd8, 0x2c, 0x99, 0x1e, 0x35, 0x31, 0xc0, 0x2d, 0x08, 0xfa, 0x3d, 0x62, 0xc7,
	0xab, 0xce, 0x3c, 0x0c, 0x21, 0xc9, 0xd1, 0x1f, 0x10, 0x5b, 0x22, 0x67, 0x4a, 0x54, 0x69, 0xe5,
	0x78, 0x66, 0x5b, 0xda, 0x48, 0xcb, 0xad, 0x5c, 0x07, 0x27, 0x55, 0x43, 0xd3, 0x1f, 0x11, 0x9b,
	0x23, 0x33, 0x55, 0x4d, 0x21, 0x0b, 0x94, 0xa5, 0x3f, 0x21, 0x76, 0x92, 0x1c, 0x2f, 0x71, 0x03,
	0x29, 0xd8, 0x8a, 0xfa, 0x19, 0xb1, 0x53, 0x64, 0xae, 0xa4, 0x12, 0x6e, 0xac, 0xe4, 0x51, 0x45,
	0xfe, 0x82, 0xd8, 0x69, 0x32, 0x5f, 0x92, 0x71, 0x16, 0x59, 0x99, 0x44, 0xe0, 0xc2, 0x96, 0x96,
	0x21, 0xa4, 0xf4, 0x46, 0x8d, 0x9d, 0x21, 0xf5, 0x11, 0xab, 0xd7, 0x41, 0xb8, 0x04, 0x4c, 0xcc,
	0x15, 0x28, 0x1b, 0xb5, 0xe9, 0xcd, 0x1a, 0x9b, 0x21, 0x53, 0x25, 0xdd, 0xd0, 0x99, 0x12, 0xf4,
	0xab, 0x1a, 0x3b, 0x41, 0xe8, 0xc8, 0x1e, 0x00, 0xa7, 0x6d, 0x0b, 0x0c, 0xbd, 0x55, 0x63, 0x75,
	0x32, 0x5b, 0xc9, 0xb6, 0x2e, 0xd6, 0x42, 0x36, 0x24, 0x08, 0xfa, 0xb5, 0x7f, 0x20, 0x4b, 0x21,
	0x77, 0xf2, 0x72, 0x9b, 0x7e, 0x53, 0x63, 0x01, 0x39, 0x59, 0xc2, 0x16, 0xe2, 0x44, 0x1b, 0x6e,
	0xda, 0xce, 0x80, 0x90, 0x06, 0x42, 0x4b, 0xbf, 0xad, 0xb1, 0x79, 0xc2, 0x4a, 0x7e, 0x95, 0x0b,
	0x67, 0xe0, 0xd9, 0x0c, 0x52, 0x4b, 0xf7, 0xb0, 0x77, 0x53, 0xa6, 0x4a, 0x0b, 0xaf, 0x80, 0xa0,
	0x6f, 0x60, 0x6f, 0xd4, 0x84, 0xb7, 0x63, 0x50, 0xb6, 0x38, 0x26, 0x0d, 0x08, 0xfa, 0x26, 0xf6,
	0x74, 0x34, 0xb4, 0x59, 0x95, 0x42, 0x80, 0xa2, 0x6f, 0xf9, 0x70, 0x2e, 0x7c, 0x38, 0xe6, 0xdb,
	0xd8, 0x93, 0x17, 0x83, 0x6d, 0x69, 0x51, 0xb0, 0x3c, 0x8a, 0xf4, 0x06, 0x08, 0xfa, 0x0e, 0x66,
	0x0b, 0xe4, 0x84, 0x77, 0x6c, 0xb8, 0x64, 0xbe, 0x1a, 0x01, 0x7d, 0x17, 0xb3, 0xb3, 0x55, 0x82,
	0x8a, 0x69, 0x8b, 0x45, 0x1f, 0x48, 0x79, 0x0f, 0x7b, 0x0b, 0x2b, 0xe7, 0x72, 0x56, 0xc6, 0xa0,
	0x33, 0x4b, 0xdf, 0xc7, 0x5e, 0x74, 0x42, 0xad, 0x1a, 0x91, 0x0c, 0x2d, 0xfd, 0x00, 0x33, 0x4a,
	0x26, 0x4b, 0xb4, 0xa9, 0x15, 0xd0, 0x0f, 0xfd, 0x26, 0x11, 0xa8, 0xa6, 0x7f, 0xc3, 0x47, 0x87,
	0x25, 0x40, 0xa8, 0x95, 0x90, 0x56, 0x6a, 0xe5, 0x1a, 0x5c, 0x46, 0x20, 0xe8, 0xc7, 0x98, 0x9d,
	0x27, 0x67, 0x8f, 0x48, 0x00, 0x65, 0xa5, 0x6d, 0x3b, 0xab, 0xb5, 0x8b, 0xb8, 0x69, 0x02, 0xfd,
	0x04, 0xb3, 0x45, 0x72, 0xea, 0x48, 0x55, 0x66, 0xe4, 0xb0, 0x44, 0xab, 0x26, 0xfd, 0x14, 0x7b,
	0x91, 0xce, 0x54, 0x9a, 0x25, 0x89, 0x36, 0x16, 0x84, 0x8b, 0x41, 0x48, 0xee, 0x6c, 0x3b, 0x01,
	0xfa, 0x19, 0x66, 0x4f, 0x91, 0x0b, 0x87, 0xbb, 0x80, 0x70, 0x86, 0xab, 0x26, 0x14, 0xde, 0xa5,
	0xdc, 0xca, 0xb4, 0x21, 0x0b, 0xf3, 0x3e, 0xf7, 0x8d, 0x87, 0xcb, 0x09, 0x84, 0xf9, 0xdb, 0x71,
	0x20, 0xfc, 0x0b, 0xcc, 0x18, 0x79, 0xac, 0xca, 0x0d, 0x4f, 0xb4, 0xa5, 0x5f, 0x62, 0x76, 0x8e,
	0x9c, 0x7e, 0xd8, 0xb4, 0x95, 0x21, 0x37, 0xb0, 0x17, 0xf4, 0x5c, 0x7d, 0xcc, 0x55, 0x7b, 0x24,
	0x26, 0xa5, 0x37, 0x1f, 0x22, 0xd1, 0xb5, 0x80, 0x0b, 0x30, 0xae, 0x21, 0x21, 0x12, 0xa9, 0xe7,
	0xca, 0x2d, 0xcc, 0x9e, 0x20, 0xe7, 0x0f, 0x12, 0xb8, 0xce, 0x65, 0x94, 0x6b, 0xcf, 0x53, 0xe5,
	0x22, 0x68, 0xf2, 0xc8, 0x19, 0xe0, 0xa9, 0x56, 0x29, 0xfd, 0xce, 0x57, 0x26, 0x95, 0x05, 0xa3,
	0x78, 0xe4, 0x52, 0x30, 0xeb, 0x60, 0x1c, 0x18, 0xa3, 0x0d, 0xfd, 0xc3, 0xdf, 0x63, 0xee, 0x86,
	0x8c, 0x93, 0x08, 0xf2, 0xec, 0x82, 0xa0, 0x7f, 0xe2, 0x23, 0x6f, 0x41, 0x93, 0x5b, 0xd8, 0xe0,
	0x6d, 0xfa, 0x97, 0xbf, 0xe0, 0xbc, 0x9f, 0x0c, 0xc1, 0xd7, 0x42, 0xff, 0xf6, 0xdb, 0x96, 0xa7,
	0xaa, 0x8c, 0xfd, 0x83, 0xd9, 0x05, 0x72, 0xae, 0x24, 0x5b, 0xd6, 0x26, 0x6e, 0x1d, 0x4c, 0x9a,
	0x1b, 0x56, 0xac, 0x63, 0xb4, 0x44, 0xfa, 0xaf, 0x6f, 0x8b, 0x02, 0xbb, 0xa1, 0xcd, 0x5a, 0x91,
	0xe5, 0x3c, 0x29, 0x21, 0x3f, 0x6c, 0xf1, 0x7f, 0x78, 0x75, 0xf5, 0xce, 0x7e, 0x30, 0xf6, 0xeb,
	0x7e, 0x30, 0x76, 0x77, 0x3f, 0x40, 0xf7, 0xf7, 0x03, 0xf4, 0xfa, 0x20, 0x40, 0xd7, 0x07, 0x01,
	0xba, 0x3d, 0x08, 0xd0, 0x9d, 0x41, 0x80, 0xee, 0x0e, 0x02, 0xf4, 0xdb, 0x20, 0x18, 0xbb, 0x3f,
	0x08, 0xd0, 0xde, 0xbd, 0x60, 0xec, 0xfa, 0xbd, 0x00, 0x5d, 0x99, 0x1a, 0x7e, 0xe0, 0xaf, 0x16,
	0xbf, 0x9b, 0xe7, 0x8e, 0x15, 0x3f, 0x9a, 0xa7, 0xff, 0x0f, 0x00, 0x00, 0xff, 0xff, 0x5d, 0x07,
	0x8f, 0x43, 0x82, 0x06, 0x00, 0x00,
}
