syntax = "proto3";

package msg;

import "msg/dataset.proto";
import "msg/status.proto";

message QueryURLRequests {
  repeated string url          = 1; // urls
  repeated DataSetType dataset = 2; // list of datasets to get for each URL
  string callback              = 3; // callback_url
  bool poll                    = 4; // user will poll for results
  bool partial_results         = 5; // user wants partial results trickled in.
  string accept                = 6; // "accept header": indicates acceptable formats for results in callback
}

message QueryContentRequests {
  message URLContent {
    // Use a unique id if content has no url, to link response to request.
    string id                  = 1; // customer supplied identifier to link to response
    string url                 = 2; // url
    map<string, string> header = 3; // headers
    string content             = 4; // content, this should be used for most requests
  }

  repeated URLContent content  = 1; // content
  repeated DataSetType dataset = 2; // DataSets
  string callback              = 3; // callback_url
  bool poll                    = 4; // user will poll for results
  bool partial_results         = 5; // user wants partial results trickled in.
  string accept                = 6; // "accept header": indicates acceptable formats for results in callback
}

message QueryReply {
  Status status             = 1; // The zvelo internal status.
  repeated bytes request_id = 2; // The request_ids are reurned in the same order as the requested URLs.

  // the target of QueryStatus, to ensure that the QueryStatus call
  // goes to the same cluster as the original call.
  // Will only be set if user set p=true in request.
  string status_url         = 3;
}

// Callback Rules:
// For each individual URL/RequestID we will POST at least one QueryResult message to
// the callback URL.
// A RequestID callback may be sent one time if all DataSets are in cache, up to
// one callback for each dataset as it becomes available.
