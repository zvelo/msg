syntax = "proto3";

package zvelo.msg;

option go_package = "zvelo.io/msg";

import "zvelo/msg/dataset.proto";
import "zvelo/msg/status.proto";

message QueryURLRequests {
  repeated string url          = 1; // urls
  repeated DataSetType dataset = 2; // list of datasets to get for each URL
  string callback              = 3; // callback_url
  bool poll                    = 4; // user will poll for results
  bool partial_results         = 5; // user wants partial results trickled in.
  string accept                = 6; // "accept header": indicates acceptable formats for results in callback
}

message QueryContentRequests {
  message URLContent {
    // Use a unique id if content has no url, to link response to request.
    string id                  = 1; // customer supplied identifier to link to response
    string url                 = 2; // url
    map<string, string> header = 3; // headers
    string content             = 4; // content, this should be used for most requests
  }

  repeated URLContent content  = 1; // content
  repeated DataSetType dataset = 2; // DataSets
  string callback              = 3; // callback_url
  bool poll                    = 4; // user will poll for results
  bool partial_results         = 5; // user wants partial results trickled in.
  string accept                = 6; // "accept header": indicates acceptable formats for results in callback
}

message QueryReply {
  Status status              = 1; // The zvelo internal status.
  string request_id          = 2; // The request_ids will identify the request after submission
  string url                 = 3; // If the original request was a URL request, this will be populated
  string tracking_id         = 4; // If the original request was a Content request, this will be populated
  // the target of QueryStatus, to ensure that the QueryStatus call
  // goes to the same cluster as the original call.
  // Will only be set if user set p=true in request.
  string status_url          = 5;
}

// If a request contained more then one URL, or piece of content, we will reply
// with this reply. Each sub-query should be reflected in the replies field,
// and with their own status.
message QueryReplies {
    repeated QueryReply replies = 1;  // this contains a reply for each sub query
    Status status = 2; // this reflects the overall status of the sub-queries
}

// Callback Rules:
// For each individual URL/RequestID we will POST at least one QueryResult message to
// the callback URL.
// A RequestID callback may be sent one time if all DataSets are in cache, up to
// one callback for each dataset as it becomes available.
