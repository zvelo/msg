// Code generated by protoc-gen-go.
// source: zvelo/msg/dataset.proto
// DO NOT EDIT!

package msg

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type DataSetType int32

const (
	DataSetType_CATEGORIZATION DataSetType = 0
	DataSetType_ADFRAUD        DataSetType = 1
	// 2 is reserved
	DataSetType_KEYWORD   DataSetType = 3
	DataSetType_MALICIOUS DataSetType = 4
	DataSetType_ECHO      DataSetType = 5
	DataSetType_SENTIMENT DataSetType = 6
)

var DataSetType_name = map[int32]string{
	0: "CATEGORIZATION",
	1: "ADFRAUD",
	3: "KEYWORD",
	4: "MALICIOUS",
	5: "ECHO",
	6: "SENTIMENT",
}
var DataSetType_value = map[string]int32{
	"CATEGORIZATION": 0,
	"ADFRAUD":        1,
	"KEYWORD":        3,
	"MALICIOUS":      4,
	"ECHO":           5,
	"SENTIMENT":      6,
}

func (x DataSetType) String() string {
	return proto.EnumName(DataSetType_name, int32(x))
}
func (DataSetType) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

type DataSet struct {
	Categorization *DataSet_Categorization `protobuf:"bytes,1,opt,name=categorization" json:"categorization,omitempty"`
	Adfraud        *DataSet_AdFraud        `protobuf:"bytes,2,opt,name=adfraud" json:"adfraud,omitempty"`
	// 3 is reserved
	// We expect that only keyword or sentiment will
	// be populated at a given point in time to not
	// duplicate data. If sentiment is not nil, then
	// it contains all of the keywords in its map,
	// and as such we don't have to populate Keyword.
	Keyword   *DataSet_Keyword   `protobuf:"bytes,4,opt,name=keyword" json:"keyword,omitempty"`
	Malicious *DataSet_Malicious `protobuf:"bytes,5,opt,name=malicious" json:"malicious,omitempty"`
	Echo      *DataSet_Echo      `protobuf:"bytes,6,opt,name=echo" json:"echo,omitempty"`
	Sentiment *DataSet_Sentiment `protobuf:"bytes,7,opt,name=sentiment" json:"sentiment,omitempty"`
}

func (m *DataSet) Reset()                    { *m = DataSet{} }
func (m *DataSet) String() string            { return proto.CompactTextString(m) }
func (*DataSet) ProtoMessage()               {}
func (*DataSet) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *DataSet) GetCategorization() *DataSet_Categorization {
	if m != nil {
		return m.Categorization
	}
	return nil
}

func (m *DataSet) GetAdfraud() *DataSet_AdFraud {
	if m != nil {
		return m.Adfraud
	}
	return nil
}

func (m *DataSet) GetKeyword() *DataSet_Keyword {
	if m != nil {
		return m.Keyword
	}
	return nil
}

func (m *DataSet) GetMalicious() *DataSet_Malicious {
	if m != nil {
		return m.Malicious
	}
	return nil
}

func (m *DataSet) GetEcho() *DataSet_Echo {
	if m != nil {
		return m.Echo
	}
	return nil
}

func (m *DataSet) GetSentiment() *DataSet_Sentiment {
	if m != nil {
		return m.Sentiment
	}
	return nil
}

type DataSet_Categorization struct {
	Values []Category `protobuf:"varint,1,rep,packed,name=values,enum=zvelo.msg.Category" json:"values,omitempty"`
}

func (m *DataSet_Categorization) Reset()                    { *m = DataSet_Categorization{} }
func (m *DataSet_Categorization) String() string            { return proto.CompactTextString(m) }
func (*DataSet_Categorization) ProtoMessage()               {}
func (*DataSet_Categorization) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 0} }

func (m *DataSet_Categorization) GetValues() []Category {
	if m != nil {
		return m.Values
	}
	return nil
}

type DataSet_AdFraud struct {
	Verdict   bool   `protobuf:"varint,1,opt,name=verdict" json:"verdict,omitempty"`
	Signature string `protobuf:"bytes,2,opt,name=signature" json:"signature,omitempty"`
}

func (m *DataSet_AdFraud) Reset()                    { *m = DataSet_AdFraud{} }
func (m *DataSet_AdFraud) String() string            { return proto.CompactTextString(m) }
func (*DataSet_AdFraud) ProtoMessage()               {}
func (*DataSet_AdFraud) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 1} }

func (m *DataSet_AdFraud) GetVerdict() bool {
	if m != nil {
		return m.Verdict
	}
	return false
}

func (m *DataSet_AdFraud) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

type DataSet_Sentiment struct {
	Values map[string]float32 `protobuf:"bytes,1,rep,name=values" json:"values,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"fixed32,2,opt,name=value"`
}

func (m *DataSet_Sentiment) Reset()                    { *m = DataSet_Sentiment{} }
func (m *DataSet_Sentiment) String() string            { return proto.CompactTextString(m) }
func (*DataSet_Sentiment) ProtoMessage()               {}
func (*DataSet_Sentiment) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 2} }

func (m *DataSet_Sentiment) GetValues() map[string]float32 {
	if m != nil {
		return m.Values
	}
	return nil
}

type DataSet_Keyword struct {
	Values []string `protobuf:"bytes,1,rep,name=values" json:"values,omitempty"`
}

func (m *DataSet_Keyword) Reset()                    { *m = DataSet_Keyword{} }
func (m *DataSet_Keyword) String() string            { return proto.CompactTextString(m) }
func (*DataSet_Keyword) ProtoMessage()               {}
func (*DataSet_Keyword) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 3} }

func (m *DataSet_Keyword) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

type DataSet_Malicious struct {
	Category Category `protobuf:"varint,1,opt,name=category,enum=zvelo.msg.Category" json:"category,omitempty"`
	// 2 reserved for signature
	Verdict bool `protobuf:"varint,3,opt,name=verdict" json:"verdict,omitempty"`
}

func (m *DataSet_Malicious) Reset()                    { *m = DataSet_Malicious{} }
func (m *DataSet_Malicious) String() string            { return proto.CompactTextString(m) }
func (*DataSet_Malicious) ProtoMessage()               {}
func (*DataSet_Malicious) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 4} }

func (m *DataSet_Malicious) GetCategory() Category {
	if m != nil {
		return m.Category
	}
	return Category_UNKNOWN
}

func (m *DataSet_Malicious) GetVerdict() bool {
	if m != nil {
		return m.Verdict
	}
	return false
}

type DataSet_Echo struct {
	Url string `protobuf:"bytes,1,opt,name=url" json:"url,omitempty"`
}

func (m *DataSet_Echo) Reset()                    { *m = DataSet_Echo{} }
func (m *DataSet_Echo) String() string            { return proto.CompactTextString(m) }
func (*DataSet_Echo) ProtoMessage()               {}
func (*DataSet_Echo) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 5} }

func (m *DataSet_Echo) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func init() {
	proto.RegisterType((*DataSet)(nil), "zvelo.msg.DataSet")
	proto.RegisterType((*DataSet_Categorization)(nil), "zvelo.msg.DataSet.Categorization")
	proto.RegisterType((*DataSet_AdFraud)(nil), "zvelo.msg.DataSet.AdFraud")
	proto.RegisterType((*DataSet_Sentiment)(nil), "zvelo.msg.DataSet.Sentiment")
	proto.RegisterType((*DataSet_Keyword)(nil), "zvelo.msg.DataSet.Keyword")
	proto.RegisterType((*DataSet_Malicious)(nil), "zvelo.msg.DataSet.Malicious")
	proto.RegisterType((*DataSet_Echo)(nil), "zvelo.msg.DataSet.Echo")
	proto.RegisterEnum("zvelo.msg.DataSetType", DataSetType_name, DataSetType_value)
}

func init() { proto.RegisterFile("zvelo/msg/dataset.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 495 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x7c, 0x93, 0x5f, 0x8f, 0x93, 0x40,
	0x14, 0xc5, 0x65, 0xfb, 0x87, 0x72, 0x51, 0x42, 0x46, 0xe3, 0x4e, 0xc8, 0x3e, 0xec, 0xfa, 0xd4,
	0xb8, 0x09, 0x4d, 0xaa, 0x0f, 0xba, 0x89, 0x89, 0xd8, 0xb2, 0x4a, 0xd6, 0x96, 0x64, 0xca, 0xae,
	0x71, 0xdf, 0x46, 0x18, 0xbb, 0x64, 0x29, 0x6c, 0x60, 0xa8, 0x61, 0xbf, 0x80, 0x7e, 0x6c, 0xc3,
	0x14, 0x68, 0x31, 0xad, 0x6f, 0xcc, 0xcc, 0xef, 0xdc, 0x7b, 0xe6, 0x5c, 0x06, 0x8e, 0x1f, 0xd7,
	0x2c, 0x4a, 0x46, 0xab, 0x6c, 0x39, 0x0a, 0x28, 0xa7, 0x19, 0xe3, 0xe6, 0x43, 0x9a, 0xf0, 0x04,
	0x29, 0xe2, 0xc0, 0x5c, 0x65, 0x4b, 0x03, 0x6f, 0x19, 0x9f, 0x72, 0xb6, 0x4c, 0xd2, 0x62, 0x03,
	0xbd, 0xfa, 0xdd, 0x07, 0x79, 0x4a, 0x39, 0x5d, 0x30, 0x8e, 0x1c, 0xd0, 0xaa, 0xd3, 0xf0, 0x91,
	0xf2, 0x30, 0x89, 0xb1, 0x74, 0x2a, 0x0d, 0xd5, 0xf1, 0x99, 0xd9, 0x54, 0x32, 0x2b, 0xd6, 0x9c,
	0xb4, 0x40, 0xf2, 0x8f, 0x10, 0xbd, 0x05, 0x99, 0x06, 0x3f, 0x53, 0x9a, 0x07, 0xf8, 0x48, 0xd4,
	0x30, 0xf6, 0xd4, 0xb0, 0x82, 0xcb, 0x92, 0x20, 0x35, 0x5a, 0xaa, 0xee, 0x59, 0xf1, 0x2b, 0x49,
	0x03, 0xdc, 0x3d, 0xa8, 0xba, 0xda, 0x10, 0xa4, 0x46, 0xd1, 0x05, 0x28, 0x2b, 0x1a, 0x85, 0x7e,
	0x98, 0xe4, 0x19, 0xee, 0x09, 0xdd, 0xc9, 0x1e, 0xdd, 0xac, 0x66, 0xc8, 0x16, 0x47, 0xe7, 0xd0,
	0x65, 0xfe, 0x5d, 0x82, 0xfb, 0x42, 0x76, 0xbc, 0x47, 0x66, 0xfb, 0x77, 0x09, 0x11, 0x50, 0xd9,
	0x28, 0x63, 0x31, 0x0f, 0x57, 0x2c, 0xe6, 0x58, 0x3e, 0xd8, 0x68, 0x51, 0x33, 0x64, 0x8b, 0x1b,
	0x1f, 0x40, 0x6b, 0x47, 0x86, 0xce, 0xa1, 0xbf, 0xa6, 0x51, 0xce, 0x32, 0x2c, 0x9d, 0x76, 0x86,
	0xda, 0xf8, 0xf9, 0x4e, 0xa9, 0x0a, 0x2d, 0x48, 0x85, 0x18, 0x16, 0xc8, 0x55, 0x5a, 0x08, 0x83,
	0xbc, 0x66, 0x69, 0x10, 0xfa, 0x5c, 0x8c, 0x67, 0x40, 0xea, 0x25, 0x3a, 0x01, 0x25, 0x0b, 0x97,
	0x31, 0xe5, 0x79, 0xca, 0x44, 0xec, 0x0a, 0xd9, 0x6e, 0x18, 0x7f, 0x24, 0x50, 0x1a, 0x6b, 0xe8,
	0x63, 0xab, 0xbb, 0x3a, 0x1e, 0xfe, 0xef, 0x22, 0xe6, 0x8d, 0x40, 0xed, 0x98, 0xef, 0x58, 0x7a,
	0x0f, 0xea, 0xce, 0x36, 0xd2, 0xa1, 0x73, 0xcf, 0x0a, 0x61, 0x49, 0x21, 0xe5, 0x27, 0x7a, 0x01,
	0x3d, 0x81, 0x0a, 0x2b, 0x47, 0x64, 0xb3, 0xb8, 0x38, 0x7a, 0x27, 0x19, 0x67, 0x20, 0x57, 0x53,
	0x44, 0x2f, 0x5b, 0x3e, 0x94, 0xa6, 0xfa, 0x0d, 0x28, 0xcd, 0xc0, 0xd0, 0x08, 0x06, 0xf5, 0x6f,
	0x2b, 0x1a, 0x1c, 0x08, 0xab, 0x81, 0x76, 0x33, 0xea, 0xb4, 0x32, 0x32, 0x30, 0x74, 0xcb, 0x89,
	0x96, 0x76, 0xf3, 0x34, 0xaa, 0xed, 0xe6, 0x69, 0xf4, 0xda, 0x07, 0xb5, 0xba, 0xb8, 0x57, 0x3c,
	0x30, 0x84, 0x40, 0x9b, 0x58, 0x9e, 0xfd, 0xd9, 0x25, 0xce, 0xad, 0xe5, 0x39, 0xee, 0x5c, 0x7f,
	0x82, 0x54, 0x90, 0xad, 0xe9, 0x25, 0xb1, 0xae, 0xa7, 0xba, 0x54, 0x2e, 0xae, 0xec, 0xef, 0xdf,
	0x5c, 0x32, 0xd5, 0x3b, 0xe8, 0x19, 0x28, 0x33, 0xeb, 0xab, 0x33, 0x71, 0xdc, 0xeb, 0x85, 0xde,
	0x45, 0x03, 0xe8, 0xda, 0x93, 0x2f, 0xae, 0xde, 0x2b, 0x0f, 0x16, 0xf6, 0xdc, 0x73, 0x66, 0xf6,
	0xdc, 0xd3, 0xfb, 0x9f, 0xb4, 0xdb, 0xa7, 0x1b, 0xe3, 0xa1, 0x78, 0x8d, 0x3f, 0xfa, 0xe2, 0x15,
	0xbe, 0xf9, 0x1b, 0x00, 0x00, 0xff, 0xff, 0x46, 0x45, 0x7b, 0x57, 0xc5, 0x03, 0x00, 0x00,
}
