// Code generated by protoc-gen-gogo.
// source: zvelo/msg/dataset.proto
// DO NOT EDIT!

package msg

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import strconv "strconv"

import strings "strings"
import reflect "reflect"
import github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type DataSetType int32

const (
	CATEGORIZATION DataSetType = 0
	ADFRAUD        DataSetType = 1
	// 2 is reserved
	KEYWORD   DataSetType = 3
	MALICIOUS DataSetType = 4
	ECHO      DataSetType = 5
	SENTIMENT DataSetType = 6
)

var DataSetType_name = map[int32]string{
	0: "CATEGORIZATION",
	1: "ADFRAUD",
	3: "KEYWORD",
	4: "MALICIOUS",
	5: "ECHO",
	6: "SENTIMENT",
}
var DataSetType_value = map[string]int32{
	"CATEGORIZATION": 0,
	"ADFRAUD":        1,
	"KEYWORD":        3,
	"MALICIOUS":      4,
	"ECHO":           5,
	"SENTIMENT":      6,
}

func (DataSetType) EnumDescriptor() ([]byte, []int) { return fileDescriptorDataset, []int{0} }

type DataSet struct {
	Categorization *DataSet_Categorization `protobuf:"bytes,1,opt,name=categorization" json:"categorization,omitempty"`
	Adfraud        *DataSet_AdFraud        `protobuf:"bytes,2,opt,name=adfraud" json:"adfraud,omitempty"`
	// 3 is reserved
	// We expect that only keyword or sentiment will
	// be populated at a given point in time to not
	// duplicate data. If sentiment is not nil, then
	// it contains all of the keywords in its map,
	// and as such we don't have to populate Keyword.
	Keyword   *DataSet_Keyword   `protobuf:"bytes,4,opt,name=keyword" json:"keyword,omitempty"`
	Malicious *DataSet_Malicious `protobuf:"bytes,5,opt,name=malicious" json:"malicious,omitempty"`
	Echo      *DataSet_Echo      `protobuf:"bytes,6,opt,name=echo" json:"echo,omitempty"`
	Sentiment *DataSet_Sentiment `protobuf:"bytes,7,opt,name=sentiment" json:"sentiment,omitempty"`
}

func (m *DataSet) Reset()                    { *m = DataSet{} }
func (*DataSet) ProtoMessage()               {}
func (*DataSet) Descriptor() ([]byte, []int) { return fileDescriptorDataset, []int{0} }

func (m *DataSet) GetCategorization() *DataSet_Categorization {
	if m != nil {
		return m.Categorization
	}
	return nil
}

func (m *DataSet) GetAdfraud() *DataSet_AdFraud {
	if m != nil {
		return m.Adfraud
	}
	return nil
}

func (m *DataSet) GetKeyword() *DataSet_Keyword {
	if m != nil {
		return m.Keyword
	}
	return nil
}

func (m *DataSet) GetMalicious() *DataSet_Malicious {
	if m != nil {
		return m.Malicious
	}
	return nil
}

func (m *DataSet) GetEcho() *DataSet_Echo {
	if m != nil {
		return m.Echo
	}
	return nil
}

func (m *DataSet) GetSentiment() *DataSet_Sentiment {
	if m != nil {
		return m.Sentiment
	}
	return nil
}

type DataSet_Categorization struct {
	Values []Category `protobuf:"varint,1,rep,packed,name=values,enum=zvelo.msg.Category" json:"values,omitempty"`
}

func (m *DataSet_Categorization) Reset()                    { *m = DataSet_Categorization{} }
func (*DataSet_Categorization) ProtoMessage()               {}
func (*DataSet_Categorization) Descriptor() ([]byte, []int) { return fileDescriptorDataset, []int{0, 0} }

func (m *DataSet_Categorization) GetValues() []Category {
	if m != nil {
		return m.Values
	}
	return nil
}

type DataSet_AdFraud struct {
	Verdict   bool   `protobuf:"varint,1,opt,name=verdict,proto3" json:"verdict,omitempty"`
	Signature string `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *DataSet_AdFraud) Reset()                    { *m = DataSet_AdFraud{} }
func (*DataSet_AdFraud) ProtoMessage()               {}
func (*DataSet_AdFraud) Descriptor() ([]byte, []int) { return fileDescriptorDataset, []int{0, 1} }

func (m *DataSet_AdFraud) GetVerdict() bool {
	if m != nil {
		return m.Verdict
	}
	return false
}

func (m *DataSet_AdFraud) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

type DataSet_Sentiment struct {
	Values map[string]float32 `protobuf:"bytes,1,rep,name=values" json:"values,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed32,2,opt,name=value,proto3"`
}

func (m *DataSet_Sentiment) Reset()                    { *m = DataSet_Sentiment{} }
func (*DataSet_Sentiment) ProtoMessage()               {}
func (*DataSet_Sentiment) Descriptor() ([]byte, []int) { return fileDescriptorDataset, []int{0, 2} }

func (m *DataSet_Sentiment) GetValues() map[string]float32 {
	if m != nil {
		return m.Values
	}
	return nil
}

type DataSet_Keyword struct {
	Values []string `protobuf:"bytes,1,rep,name=values" json:"values,omitempty"`
}

func (m *DataSet_Keyword) Reset()                    { *m = DataSet_Keyword{} }
func (*DataSet_Keyword) ProtoMessage()               {}
func (*DataSet_Keyword) Descriptor() ([]byte, []int) { return fileDescriptorDataset, []int{0, 3} }

func (m *DataSet_Keyword) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

type DataSet_Malicious struct {
	Category Category `protobuf:"varint,1,opt,name=category,proto3,enum=zvelo.msg.Category" json:"category,omitempty"`
	// 2 reserved for signature
	Verdict bool `protobuf:"varint,3,opt,name=verdict,proto3" json:"verdict,omitempty"`
}

func (m *DataSet_Malicious) Reset()                    { *m = DataSet_Malicious{} }
func (*DataSet_Malicious) ProtoMessage()               {}
func (*DataSet_Malicious) Descriptor() ([]byte, []int) { return fileDescriptorDataset, []int{0, 4} }

func (m *DataSet_Malicious) GetCategory() Category {
	if m != nil {
		return m.Category
	}
	return UNKNOWN_CATEGORY
}

func (m *DataSet_Malicious) GetVerdict() bool {
	if m != nil {
		return m.Verdict
	}
	return false
}

type DataSet_Echo struct {
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
}

func (m *DataSet_Echo) Reset()                    { *m = DataSet_Echo{} }
func (*DataSet_Echo) ProtoMessage()               {}
func (*DataSet_Echo) Descriptor() ([]byte, []int) { return fileDescriptorDataset, []int{0, 5} }

func (m *DataSet_Echo) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func init() {
	proto.RegisterType((*DataSet)(nil), "zvelo.msg.DataSet")
	proto.RegisterType((*DataSet_Categorization)(nil), "zvelo.msg.DataSet.Categorization")
	proto.RegisterType((*DataSet_AdFraud)(nil), "zvelo.msg.DataSet.AdFraud")
	proto.RegisterType((*DataSet_Sentiment)(nil), "zvelo.msg.DataSet.Sentiment")
	proto.RegisterType((*DataSet_Keyword)(nil), "zvelo.msg.DataSet.Keyword")
	proto.RegisterType((*DataSet_Malicious)(nil), "zvelo.msg.DataSet.Malicious")
	proto.RegisterType((*DataSet_Echo)(nil), "zvelo.msg.DataSet.Echo")
	proto.RegisterEnum("zvelo.msg.DataSetType", DataSetType_name, DataSetType_value)
}
func (x DataSetType) String() string {
	s, ok := DataSetType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *DataSet) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DataSet)
	if !ok {
		that2, ok := that.(DataSet)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *DataSet")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DataSet but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DataSet but is not nil && this == nil")
	}
	if !this.Categorization.Equal(that1.Categorization) {
		return fmt.Errorf("Categorization this(%v) Not Equal that(%v)", this.Categorization, that1.Categorization)
	}
	if !this.Adfraud.Equal(that1.Adfraud) {
		return fmt.Errorf("Adfraud this(%v) Not Equal that(%v)", this.Adfraud, that1.Adfraud)
	}
	if !this.Keyword.Equal(that1.Keyword) {
		return fmt.Errorf("Keyword this(%v) Not Equal that(%v)", this.Keyword, that1.Keyword)
	}
	if !this.Malicious.Equal(that1.Malicious) {
		return fmt.Errorf("Malicious this(%v) Not Equal that(%v)", this.Malicious, that1.Malicious)
	}
	if !this.Echo.Equal(that1.Echo) {
		return fmt.Errorf("Echo this(%v) Not Equal that(%v)", this.Echo, that1.Echo)
	}
	if !this.Sentiment.Equal(that1.Sentiment) {
		return fmt.Errorf("Sentiment this(%v) Not Equal that(%v)", this.Sentiment, that1.Sentiment)
	}
	return nil
}
func (this *DataSet) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DataSet)
	if !ok {
		that2, ok := that.(DataSet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Categorization.Equal(that1.Categorization) {
		return false
	}
	if !this.Adfraud.Equal(that1.Adfraud) {
		return false
	}
	if !this.Keyword.Equal(that1.Keyword) {
		return false
	}
	if !this.Malicious.Equal(that1.Malicious) {
		return false
	}
	if !this.Echo.Equal(that1.Echo) {
		return false
	}
	if !this.Sentiment.Equal(that1.Sentiment) {
		return false
	}
	return true
}
func (this *DataSet_Categorization) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DataSet_Categorization)
	if !ok {
		that2, ok := that.(DataSet_Categorization)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *DataSet_Categorization")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DataSet_Categorization but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DataSet_Categorization but is not nil && this == nil")
	}
	if len(this.Values) != len(that1.Values) {
		return fmt.Errorf("Values this(%v) Not Equal that(%v)", len(this.Values), len(that1.Values))
	}
	for i := range this.Values {
		if this.Values[i] != that1.Values[i] {
			return fmt.Errorf("Values this[%v](%v) Not Equal that[%v](%v)", i, this.Values[i], i, that1.Values[i])
		}
	}
	return nil
}
func (this *DataSet_Categorization) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DataSet_Categorization)
	if !ok {
		that2, ok := that.(DataSet_Categorization)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Values) != len(that1.Values) {
		return false
	}
	for i := range this.Values {
		if this.Values[i] != that1.Values[i] {
			return false
		}
	}
	return true
}
func (this *DataSet_AdFraud) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DataSet_AdFraud)
	if !ok {
		that2, ok := that.(DataSet_AdFraud)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *DataSet_AdFraud")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DataSet_AdFraud but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DataSet_AdFraud but is not nil && this == nil")
	}
	if this.Verdict != that1.Verdict {
		return fmt.Errorf("Verdict this(%v) Not Equal that(%v)", this.Verdict, that1.Verdict)
	}
	if this.Signature != that1.Signature {
		return fmt.Errorf("Signature this(%v) Not Equal that(%v)", this.Signature, that1.Signature)
	}
	return nil
}
func (this *DataSet_AdFraud) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DataSet_AdFraud)
	if !ok {
		that2, ok := that.(DataSet_AdFraud)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Verdict != that1.Verdict {
		return false
	}
	if this.Signature != that1.Signature {
		return false
	}
	return true
}
func (this *DataSet_Sentiment) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DataSet_Sentiment)
	if !ok {
		that2, ok := that.(DataSet_Sentiment)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *DataSet_Sentiment")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DataSet_Sentiment but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DataSet_Sentiment but is not nil && this == nil")
	}
	if len(this.Values) != len(that1.Values) {
		return fmt.Errorf("Values this(%v) Not Equal that(%v)", len(this.Values), len(that1.Values))
	}
	for i := range this.Values {
		if this.Values[i] != that1.Values[i] {
			return fmt.Errorf("Values this[%v](%v) Not Equal that[%v](%v)", i, this.Values[i], i, that1.Values[i])
		}
	}
	return nil
}
func (this *DataSet_Sentiment) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DataSet_Sentiment)
	if !ok {
		that2, ok := that.(DataSet_Sentiment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Values) != len(that1.Values) {
		return false
	}
	for i := range this.Values {
		if this.Values[i] != that1.Values[i] {
			return false
		}
	}
	return true
}
func (this *DataSet_Keyword) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DataSet_Keyword)
	if !ok {
		that2, ok := that.(DataSet_Keyword)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *DataSet_Keyword")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DataSet_Keyword but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DataSet_Keyword but is not nil && this == nil")
	}
	if len(this.Values) != len(that1.Values) {
		return fmt.Errorf("Values this(%v) Not Equal that(%v)", len(this.Values), len(that1.Values))
	}
	for i := range this.Values {
		if this.Values[i] != that1.Values[i] {
			return fmt.Errorf("Values this[%v](%v) Not Equal that[%v](%v)", i, this.Values[i], i, that1.Values[i])
		}
	}
	return nil
}
func (this *DataSet_Keyword) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DataSet_Keyword)
	if !ok {
		that2, ok := that.(DataSet_Keyword)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Values) != len(that1.Values) {
		return false
	}
	for i := range this.Values {
		if this.Values[i] != that1.Values[i] {
			return false
		}
	}
	return true
}
func (this *DataSet_Malicious) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DataSet_Malicious)
	if !ok {
		that2, ok := that.(DataSet_Malicious)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *DataSet_Malicious")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DataSet_Malicious but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DataSet_Malicious but is not nil && this == nil")
	}
	if this.Category != that1.Category {
		return fmt.Errorf("Category this(%v) Not Equal that(%v)", this.Category, that1.Category)
	}
	if this.Verdict != that1.Verdict {
		return fmt.Errorf("Verdict this(%v) Not Equal that(%v)", this.Verdict, that1.Verdict)
	}
	return nil
}
func (this *DataSet_Malicious) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DataSet_Malicious)
	if !ok {
		that2, ok := that.(DataSet_Malicious)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Category != that1.Category {
		return false
	}
	if this.Verdict != that1.Verdict {
		return false
	}
	return true
}
func (this *DataSet_Echo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DataSet_Echo)
	if !ok {
		that2, ok := that.(DataSet_Echo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *DataSet_Echo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DataSet_Echo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DataSet_Echo but is not nil && this == nil")
	}
	if this.Url != that1.Url {
		return fmt.Errorf("Url this(%v) Not Equal that(%v)", this.Url, that1.Url)
	}
	return nil
}
func (this *DataSet_Echo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DataSet_Echo)
	if !ok {
		that2, ok := that.(DataSet_Echo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Url != that1.Url {
		return false
	}
	return true
}
func (this *DataSet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&msg.DataSet{")
	if this.Categorization != nil {
		s = append(s, "Categorization: "+fmt.Sprintf("%#v", this.Categorization)+",\n")
	}
	if this.Adfraud != nil {
		s = append(s, "Adfraud: "+fmt.Sprintf("%#v", this.Adfraud)+",\n")
	}
	if this.Keyword != nil {
		s = append(s, "Keyword: "+fmt.Sprintf("%#v", this.Keyword)+",\n")
	}
	if this.Malicious != nil {
		s = append(s, "Malicious: "+fmt.Sprintf("%#v", this.Malicious)+",\n")
	}
	if this.Echo != nil {
		s = append(s, "Echo: "+fmt.Sprintf("%#v", this.Echo)+",\n")
	}
	if this.Sentiment != nil {
		s = append(s, "Sentiment: "+fmt.Sprintf("%#v", this.Sentiment)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataSet_Categorization) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&msg.DataSet_Categorization{")
	s = append(s, "Values: "+fmt.Sprintf("%#v", this.Values)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataSet_AdFraud) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&msg.DataSet_AdFraud{")
	s = append(s, "Verdict: "+fmt.Sprintf("%#v", this.Verdict)+",\n")
	s = append(s, "Signature: "+fmt.Sprintf("%#v", this.Signature)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataSet_Sentiment) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&msg.DataSet_Sentiment{")
	keysForValues := make([]string, 0, len(this.Values))
	for k, _ := range this.Values {
		keysForValues = append(keysForValues, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForValues)
	mapStringForValues := "map[string]float32{"
	for _, k := range keysForValues {
		mapStringForValues += fmt.Sprintf("%#v: %#v,", k, this.Values[k])
	}
	mapStringForValues += "}"
	if this.Values != nil {
		s = append(s, "Values: "+mapStringForValues+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataSet_Keyword) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&msg.DataSet_Keyword{")
	s = append(s, "Values: "+fmt.Sprintf("%#v", this.Values)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataSet_Malicious) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&msg.DataSet_Malicious{")
	s = append(s, "Category: "+fmt.Sprintf("%#v", this.Category)+",\n")
	s = append(s, "Verdict: "+fmt.Sprintf("%#v", this.Verdict)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataSet_Echo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&msg.DataSet_Echo{")
	s = append(s, "Url: "+fmt.Sprintf("%#v", this.Url)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringDataset(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *DataSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataSet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Categorization != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDataset(dAtA, i, uint64(m.Categorization.Size()))
		n1, err := m.Categorization.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Adfraud != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDataset(dAtA, i, uint64(m.Adfraud.Size()))
		n2, err := m.Adfraud.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Keyword != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDataset(dAtA, i, uint64(m.Keyword.Size()))
		n3, err := m.Keyword.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Malicious != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDataset(dAtA, i, uint64(m.Malicious.Size()))
		n4, err := m.Malicious.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Echo != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintDataset(dAtA, i, uint64(m.Echo.Size()))
		n5, err := m.Echo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Sentiment != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintDataset(dAtA, i, uint64(m.Sentiment.Size()))
		n6, err := m.Sentiment.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *DataSet_Categorization) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataSet_Categorization) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		dAtA8 := make([]byte, len(m.Values)*10)
		var j7 int
		for _, num := range m.Values {
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintDataset(dAtA, i, uint64(j7))
		i += copy(dAtA[i:], dAtA8[:j7])
	}
	return i, nil
}

func (m *DataSet_AdFraud) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataSet_AdFraud) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Verdict {
		dAtA[i] = 0x8
		i++
		if m.Verdict {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Signature) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDataset(dAtA, i, uint64(len(m.Signature)))
		i += copy(dAtA[i:], m.Signature)
	}
	return i, nil
}

func (m *DataSet_Sentiment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataSet_Sentiment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		for k, _ := range m.Values {
			dAtA[i] = 0xa
			i++
			v := m.Values[k]
			mapSize := 1 + len(k) + sovDataset(uint64(len(k))) + 1 + 4
			i = encodeVarintDataset(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintDataset(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x15
			i++
			i = encodeFixed32Dataset(dAtA, i, uint32(math.Float32bits(float32(v))))
		}
	}
	return i, nil
}

func (m *DataSet_Keyword) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataSet_Keyword) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *DataSet_Malicious) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataSet_Malicious) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Category != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDataset(dAtA, i, uint64(m.Category))
	}
	if m.Verdict {
		dAtA[i] = 0x18
		i++
		if m.Verdict {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *DataSet_Echo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataSet_Echo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDataset(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	return i, nil
}

func encodeFixed64Dataset(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Dataset(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintDataset(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *DataSet) Size() (n int) {
	var l int
	_ = l
	if m.Categorization != nil {
		l = m.Categorization.Size()
		n += 1 + l + sovDataset(uint64(l))
	}
	if m.Adfraud != nil {
		l = m.Adfraud.Size()
		n += 1 + l + sovDataset(uint64(l))
	}
	if m.Keyword != nil {
		l = m.Keyword.Size()
		n += 1 + l + sovDataset(uint64(l))
	}
	if m.Malicious != nil {
		l = m.Malicious.Size()
		n += 1 + l + sovDataset(uint64(l))
	}
	if m.Echo != nil {
		l = m.Echo.Size()
		n += 1 + l + sovDataset(uint64(l))
	}
	if m.Sentiment != nil {
		l = m.Sentiment.Size()
		n += 1 + l + sovDataset(uint64(l))
	}
	return n
}

func (m *DataSet_Categorization) Size() (n int) {
	var l int
	_ = l
	if len(m.Values) > 0 {
		l = 0
		for _, e := range m.Values {
			l += sovDataset(uint64(e))
		}
		n += 1 + sovDataset(uint64(l)) + l
	}
	return n
}

func (m *DataSet_AdFraud) Size() (n int) {
	var l int
	_ = l
	if m.Verdict {
		n += 2
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovDataset(uint64(l))
	}
	return n
}

func (m *DataSet_Sentiment) Size() (n int) {
	var l int
	_ = l
	if len(m.Values) > 0 {
		for k, v := range m.Values {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovDataset(uint64(len(k))) + 1 + 4
			n += mapEntrySize + 1 + sovDataset(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DataSet_Keyword) Size() (n int) {
	var l int
	_ = l
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			l = len(s)
			n += 1 + l + sovDataset(uint64(l))
		}
	}
	return n
}

func (m *DataSet_Malicious) Size() (n int) {
	var l int
	_ = l
	if m.Category != 0 {
		n += 1 + sovDataset(uint64(m.Category))
	}
	if m.Verdict {
		n += 2
	}
	return n
}

func (m *DataSet_Echo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovDataset(uint64(l))
	}
	return n
}

func sovDataset(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozDataset(x uint64) (n int) {
	return sovDataset(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *DataSet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataSet{`,
		`Categorization:` + strings.Replace(fmt.Sprintf("%v", this.Categorization), "DataSet_Categorization", "DataSet_Categorization", 1) + `,`,
		`Adfraud:` + strings.Replace(fmt.Sprintf("%v", this.Adfraud), "DataSet_AdFraud", "DataSet_AdFraud", 1) + `,`,
		`Keyword:` + strings.Replace(fmt.Sprintf("%v", this.Keyword), "DataSet_Keyword", "DataSet_Keyword", 1) + `,`,
		`Malicious:` + strings.Replace(fmt.Sprintf("%v", this.Malicious), "DataSet_Malicious", "DataSet_Malicious", 1) + `,`,
		`Echo:` + strings.Replace(fmt.Sprintf("%v", this.Echo), "DataSet_Echo", "DataSet_Echo", 1) + `,`,
		`Sentiment:` + strings.Replace(fmt.Sprintf("%v", this.Sentiment), "DataSet_Sentiment", "DataSet_Sentiment", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataSet_Categorization) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataSet_Categorization{`,
		`Values:` + fmt.Sprintf("%v", this.Values) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataSet_AdFraud) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataSet_AdFraud{`,
		`Verdict:` + fmt.Sprintf("%v", this.Verdict) + `,`,
		`Signature:` + fmt.Sprintf("%v", this.Signature) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataSet_Sentiment) String() string {
	if this == nil {
		return "nil"
	}
	keysForValues := make([]string, 0, len(this.Values))
	for k, _ := range this.Values {
		keysForValues = append(keysForValues, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForValues)
	mapStringForValues := "map[string]float32{"
	for _, k := range keysForValues {
		mapStringForValues += fmt.Sprintf("%v: %v,", k, this.Values[k])
	}
	mapStringForValues += "}"
	s := strings.Join([]string{`&DataSet_Sentiment{`,
		`Values:` + mapStringForValues + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataSet_Keyword) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataSet_Keyword{`,
		`Values:` + fmt.Sprintf("%v", this.Values) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataSet_Malicious) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataSet_Malicious{`,
		`Category:` + fmt.Sprintf("%v", this.Category) + `,`,
		`Verdict:` + fmt.Sprintf("%v", this.Verdict) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataSet_Echo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataSet_Echo{`,
		`Url:` + fmt.Sprintf("%v", this.Url) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringDataset(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *DataSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataset
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Categorization", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Categorization == nil {
				m.Categorization = &DataSet_Categorization{}
			}
			if err := m.Categorization.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Adfraud", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Adfraud == nil {
				m.Adfraud = &DataSet_AdFraud{}
			}
			if err := m.Adfraud.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Keyword == nil {
				m.Keyword = &DataSet_Keyword{}
			}
			if err := m.Keyword.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Malicious", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Malicious == nil {
				m.Malicious = &DataSet_Malicious{}
			}
			if err := m.Malicious.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Echo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Echo == nil {
				m.Echo = &DataSet_Echo{}
			}
			if err := m.Echo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sentiment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sentiment == nil {
				m.Sentiment = &DataSet_Sentiment{}
			}
			if err := m.Sentiment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDataset(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDataset
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataSet_Categorization) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataset
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Categorization: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Categorization: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v Category
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDataset
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (Category(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Values = append(m.Values, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDataset
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDataset
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v Category
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDataset
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (Category(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Values = append(m.Values, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDataset(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDataset
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataSet_AdFraud) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataset
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdFraud: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdFraud: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verdict", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Verdict = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDataset(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDataset
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataSet_Sentiment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataset
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sentiment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sentiment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthDataset
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Values == nil {
				m.Values = make(map[string]float32)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDataset
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvaluetemp uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				mapvaluetemp = uint32(dAtA[iNdEx-4])
				mapvaluetemp |= uint32(dAtA[iNdEx-3]) << 8
				mapvaluetemp |= uint32(dAtA[iNdEx-2]) << 16
				mapvaluetemp |= uint32(dAtA[iNdEx-1]) << 24
				mapvalue := math.Float32frombits(mapvaluetemp)
				m.Values[mapkey] = mapvalue
			} else {
				var mapvalue float32
				m.Values[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDataset(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDataset
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataSet_Keyword) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataset
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Keyword: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Keyword: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDataset(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDataset
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataSet_Malicious) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataset
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Malicious: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Malicious: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Category", wireType)
			}
			m.Category = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Category |= (Category(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verdict", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Verdict = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDataset(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDataset
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataSet_Echo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataset
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Echo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Echo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataset
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDataset(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDataset
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDataset(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDataset
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDataset
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthDataset
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowDataset
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipDataset(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthDataset = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDataset   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("zvelo/msg/dataset.proto", fileDescriptorDataset) }

var fileDescriptorDataset = []byte{
	// 556 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x93, 0xcd, 0x6e, 0xd3, 0x4e,
	0x14, 0xc5, 0x33, 0xcd, 0x87, 0xe3, 0x9b, 0xff, 0x3f, 0xb2, 0x06, 0x44, 0x2d, 0xab, 0x1a, 0xb5,
	0xac, 0x22, 0x2a, 0x39, 0x52, 0x60, 0x01, 0x95, 0x40, 0x98, 0xc4, 0x05, 0xab, 0x24, 0x91, 0x26,
	0x69, 0x11, 0xdd, 0x19, 0x7b, 0x48, 0xad, 0x26, 0x71, 0x65, 0x8f, 0x83, 0xd2, 0x15, 0x3b, 0x58,
	0xf2, 0x18, 0x3c, 0x0a, 0xcb, 0x2e, 0x59, 0x36, 0x66, 0xc3, 0xb2, 0x8f, 0x80, 0x3c, 0xb1, 0xf3,
	0x81, 0x12, 0x76, 0x9e, 0x99, 0xdf, 0xb9, 0xf7, 0xcc, 0xb9, 0x1e, 0xd8, 0xbd, 0x9e, 0xb0, 0xa1,
	0x5f, 0x1f, 0x85, 0x83, 0xba, 0x6b, 0x73, 0x3b, 0x64, 0x5c, 0xbf, 0x0a, 0x7c, 0xee, 0x63, 0x59,
	0x1c, 0xe8, 0xa3, 0x70, 0xa0, 0xa9, 0x4b, 0xc6, 0xb1, 0x39, 0x1b, 0xf8, 0xc1, 0x74, 0x0e, 0x3d,
	0xfc, 0x52, 0x02, 0xa9, 0x65, 0x73, 0xbb, 0xc7, 0x38, 0xb6, 0xa0, 0x9a, 0x9e, 0x7a, 0xd7, 0x36,
	0xf7, 0xfc, 0xb1, 0x8a, 0xf6, 0x51, 0xad, 0xd2, 0x38, 0xd0, 0x17, 0x95, 0xf4, 0x94, 0xd5, 0x9b,
	0x6b, 0x20, 0xfd, 0x4b, 0x88, 0x9f, 0x80, 0x64, 0xbb, 0x1f, 0x03, 0x3b, 0x72, 0xd5, 0x1d, 0x51,
	0x43, 0xdb, 0x50, 0xc3, 0x70, 0x8f, 0x13, 0x82, 0x66, 0x68, 0xa2, 0xba, 0x64, 0xd3, 0x4f, 0x7e,
	0xe0, 0xaa, 0x85, 0xad, 0xaa, 0x93, 0x39, 0x41, 0x33, 0x14, 0x1f, 0x81, 0x3c, 0xb2, 0x87, 0x9e,
	0xe3, 0xf9, 0x51, 0xa8, 0x16, 0x85, 0x6e, 0x6f, 0x83, 0xae, 0x9d, 0x31, 0x74, 0x89, 0xe3, 0x43,
	0x28, 0x30, 0xe7, 0xc2, 0x57, 0x4b, 0x42, 0xb6, 0xbb, 0x41, 0x66, 0x3a, 0x17, 0x3e, 0x15, 0x50,
	0xd2, 0x28, 0x64, 0x63, 0xee, 0x8d, 0xd8, 0x98, 0xab, 0xd2, 0xd6, 0x46, 0xbd, 0x8c, 0xa1, 0x4b,
	0x5c, 0x7b, 0x0e, 0xd5, 0xf5, 0xc8, 0xf0, 0x21, 0x94, 0x26, 0xf6, 0x30, 0x62, 0xa1, 0x8a, 0xf6,
	0xf3, 0xb5, 0x6a, 0xe3, 0xde, 0x4a, 0xa9, 0x14, 0x9d, 0xd2, 0x14, 0xd1, 0x0c, 0x90, 0xd2, 0xb4,
	0xb0, 0x0a, 0xd2, 0x84, 0x05, 0xae, 0xe7, 0x70, 0x31, 0x9e, 0x32, 0xcd, 0x96, 0x78, 0x0f, 0xe4,
	0xd0, 0x1b, 0x8c, 0x6d, 0x1e, 0x05, 0x4c, 0xc4, 0x2e, 0xd3, 0xe5, 0x86, 0xf6, 0x15, 0x81, 0xbc,
	0xb0, 0x86, 0x5f, 0xae, 0x75, 0xaf, 0x34, 0x6a, 0xff, 0xba, 0x88, 0x7e, 0x26, 0x50, 0x73, 0xcc,
	0x57, 0x2c, 0x3d, 0x83, 0xca, 0xca, 0x36, 0x56, 0x20, 0x7f, 0xc9, 0xa6, 0xc2, 0x92, 0x4c, 0x93,
	0x4f, 0x7c, 0x1f, 0x8a, 0x02, 0x15, 0x56, 0x76, 0xe8, 0x7c, 0x71, 0xb4, 0xf3, 0x14, 0x69, 0x07,
	0x20, 0xa5, 0x53, 0xc4, 0x0f, 0xd6, 0x7c, 0xc8, 0x8b, 0xea, 0x67, 0x20, 0x2f, 0x06, 0x86, 0xeb,
	0x50, 0xce, 0x7e, 0x5b, 0xd1, 0x60, 0x4b, 0x58, 0x0b, 0x68, 0x35, 0xa3, 0xfc, 0x5a, 0x46, 0x9a,
	0x0a, 0x85, 0x64, 0xa2, 0x89, 0xdd, 0x28, 0x18, 0x66, 0x76, 0xa3, 0x60, 0xf8, 0xc8, 0x81, 0x4a,
	0x7a, 0xf1, 0xfe, 0xf4, 0x8a, 0x61, 0x0c, 0xd5, 0xa6, 0xd1, 0x37, 0x5f, 0x77, 0xa9, 0x75, 0x6e,
	0xf4, 0xad, 0x6e, 0x47, 0xc9, 0xe1, 0x0a, 0x48, 0x46, 0xeb, 0x98, 0x1a, 0xa7, 0x2d, 0x05, 0x25,
	0x8b, 0x13, 0xf3, 0xfd, 0xbb, 0x2e, 0x6d, 0x29, 0x79, 0xfc, 0x3f, 0xc8, 0x6d, 0xe3, 0xad, 0xd5,
	0xb4, 0xba, 0xa7, 0x3d, 0xa5, 0x80, 0xcb, 0x50, 0x30, 0x9b, 0x6f, 0xba, 0x4a, 0x31, 0x39, 0xe8,
	0x99, 0x9d, 0xbe, 0xd5, 0x36, 0x3b, 0x7d, 0xa5, 0xf4, 0xea, 0xc5, 0xcd, 0x8c, 0xe4, 0x7e, 0xce,
	0x48, 0xee, 0x76, 0x46, 0xd0, 0xdd, 0x8c, 0xa0, 0xcf, 0x31, 0x41, 0xdf, 0x63, 0x82, 0x7e, 0xc4,
	0x04, 0xdd, 0xc4, 0x04, 0xdd, 0xc6, 0x04, 0xfd, 0x8e, 0x49, 0xee, 0x2e, 0x26, 0xe8, 0xdb, 0x2f,
	0x92, 0x3b, 0xff, 0x6f, 0x7e, 0x51, 0x4f, 0xbc, 0xde, 0x0f, 0x25, 0xf1, 0x6a, 0x1f, 0xff, 0x09,
	0x00, 0x00, 0xff, 0xff, 0xe4, 0xbb, 0xe5, 0x47, 0xf5, 0x03, 0x00, 0x00,
}
