syntax = "proto3";

package zvelo.msg;

option go_package = "zvelo.io/msg";

import "zvelo/msg/dataset.proto";
import "zvelo/msg/status.proto";

message QueryResultRequest {
  string request_id = 1;
};

message QueryResult {
  string request_id                    = 1; // Request ID for tracking requests
  string tracking_id                   = 2; // Provided by user to link to responses
  reserved 3;
  Status status                        = 4; // This is the zvelo internal status
  reserved 5;
  repeated DataSetType request_dataset = 6;
  DataSet response_dataset             = 7;
  string url                           = 8;
};

message QueryURLRequests {
  repeated string url          = 1; // urls
  repeated DataSetType dataset = 2; // list of datasets to get for each URL
  string callback              = 3; // callback_url
  bool poll                    = 4; // user will poll for results
  bool partial_results         = 5; // user wants partial results trickled in.
  string accept                = 6; // "accept header": indicates acceptable formats for results in callback
}

message QueryContentRequests {
  message URLContent {
    // Use a unique id if content has no url, to link response to request.
    string id                  = 1; // customer supplied identifier to link to response
    string url                 = 2; // url
    map<string, string> header = 3; // headers
    string content             = 4; // content, this should be used for most requests
  }

  repeated URLContent content  = 1; // content
  repeated DataSetType dataset = 2; // DataSets
  string callback              = 3; // callback_url
  bool poll                    = 4; // user will poll for results
  bool partial_results         = 5; // user wants partial results trickled in.
  string accept                = 6; // "accept header": indicates acceptable formats for results in callback
}

message QueryReply {
  Status status              = 1; // The zvelo internal status.
  string request_id          = 2; // The request_ids will identify the request after submission
}

// If a request contained more then one URL, or piece of content, we will reply
// with this reply. Each sub-query should be reflected in the replies field,
// and with their own status. The position in the array will correspond to the
// index in the original array of URL or Content provided in the QueryURLRequests
// or QueryContentRequests message
message QueryReplies {
    repeated QueryReply replies = 1;  // this contains a reply for each sub query
}

// Callback Rules:
// For each individual URL/RequestID we will POST at least one QueryResult message to
// the callback URL.
// A RequestID callback may be sent one time if all DataSets are in cache, up to
// one callback for each dataset as it becomes available.
